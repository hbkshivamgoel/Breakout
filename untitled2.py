# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FOS5Vgwir4RKkVk17qbD0tP7uct98CEK
"""

!pip install yfinance --upgrade --no-cache-dir
!pip install alpha_vantage
!pip install backtesting
!pip install yahoofinancials
!pip install quandl
!pip install nltk
!pip install vaderSentiment
!pip install textblob
!pip install selenium



import altair as alt
import copy
import csv
import datetime as dt
import io
import math
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import pandas_datareader as  web
import quandl
import requests
import seaborn as sns
import statsmodels.api as sm
import time
import yfinance as yf

from alpha_vantage.timeseries import TimeSeries
from backtesting import Backtest, Strategy
from backtesting.lib import crossover
from backtesting.test import SMA, GOOG
from datetime import datetime
from google.colab import files
from pandas_datareader import data
from sklearn import datasets
from sklearn import manifold
from vega_datasets import data
from yahoofinancials import YahooFinancials



def smooth_data(Df_temp):
  Stock=Df_temp[Df_temp.columns[5:]] 

  Stock['SMA_5'] = (Stock.shift(1, axis = 0)).iloc[:,0].rolling(window=4).mean()
  Stock['SMA_8'] = (Stock.shift(1, axis = 0)).iloc[:,0].rolling(window=7).mean()
  Stock['SMA_10'] = (Stock.shift(1, axis = 0)).iloc[:,0].rolling(window=9).mean()
  Stock['SMA_13'] = (Stock.shift(1, axis = 0)).iloc[:,0].rolling(window=12).mean()
  Stock['SMA_20'] = (Stock.shift(1, axis = 0)).iloc[:,0].rolling(window=19).mean()
  Stock['SMA_34'] = (Stock.shift(1, axis = 0)).iloc[:,0].rolling(window=33).mean()
  Stock['SMA_55'] = (Stock.shift(1, axis = 0)).iloc[:,0].rolling(window=54).mean()
  Stock['SMA_100'] = (Stock.shift(1, axis = 0)).iloc[:,0].rolling(window=99).mean()
  Stock['SMA_150'] = (Stock.shift(1, axis = 0)).iloc[:,0].rolling(window=149).mean()
  Stock['SMA_200'] = (Stock.shift(1, axis = 0)).iloc[:,0].rolling(window=199).mean()
  Stock['Max']= Stock[['SMA_5', 'SMA_8','SMA_10','SMA_13','SMA_20','SMA_34','SMA_55','SMA_100','SMA_150','SMA_200']].max(axis=1,skipna = True)
  Stock['Min']= Stock[['SMA_5', 'SMA_8','SMA_10','SMA_13','SMA_20','SMA_34','SMA_55','SMA_100','SMA_150','SMA_200']].min(axis=1,skipna = True)
  Stock['Median']=Stock[['SMA_5', 'SMA_8','SMA_10','SMA_13','SMA_20','SMA_34','SMA_55','SMA_100','SMA_150','SMA_200']].median(axis = 1, skipna = True)
  df_final = Stock[['Adj Close', 'Max','Min','Median']].resample('M').last()
  return df_final



def slope(ser,n):
    "function to calculate the slope of regression line for n consecutive points on a plot"
    ser = (ser - ser.min())/(ser.max() - ser.min())
    x = np.array(range(len(ser)))
    x = (x - x.min())/(x.max() - x.min())
    slopes = [i*0 for i in range(n-1)]
    for i in range(n,len(ser)+1):
        y_scaled = ser[i-n:i]
        x_scaled = x[:n]
        x_scaled = sm.add_constant(x_scaled)
        model = sm.OLS(y_scaled,x_scaled)
        results = model.fit()
        slopes.append(results.params[-1])
    slope_angle = (np.rad2deg(np.arctan(np.array(slopes))))
    return np.array(slope_angle)


def CAGR(DF):
    "function to calculate the Cumulative Annual Growth Rate of a trading strategy"
    df = DF.copy()
    df["cum_return"] = (1 + df["mon_ret"]).cumprod()
    n = len(df)/252
    CAGR = (df["cum_return"].tolist()[-1])**(1/n) - 1
    return CAGR

def volatility(DF):
    "function to calculate annualized volatility of a trading strategy"
    df = DF.copy()
    vol = df["mon_ret"].std() * np.sqrt(252)
    return vol

def sharpe(DF,rf):
    "function to calculate sharpe ratio ; rf is the risk free rate"
    df = DF.copy()
    sr = (CAGR(df) - rf)/volatility(df)
    return sr
    

def max_dd(DF):
    "function to calculate max drawdown"
    df = DF.copy()
    df["cum_return"] = (1 + df["mon_ret"]).cumprod()
    df["cum_roll_max"] = df["cum_return"].cummax()
    df["drawdown"] = df["cum_roll_max"] - df["cum_return"]
    df["drawdown_pct"] = df["drawdown"]/df["cum_roll_max"]
    max_dd = df["drawdown_pct"].max()
    return max_dd

def ATR(DF,n):
    "function to calculate True Range and Average True Range"
    df = DF.copy()
    df['H-L']=abs(df['High']-df['Low'])
    df['H-PC']=abs(df['High']-df['Close'].shift(1))
    df['L-PC']=abs(df['Low']-df['Close'].shift(1))
    df['TR']=df[['H-L','H-PC','L-PC']].max(axis=1,skipna=False)
    df['ATR'] = df['TR'].rolling(n).mean()
    #df['ATR'] = df['TR'].ewm(span=n,adjust=False,min_periods=n).mean()
    df2 = df.drop(['H-L','H-PC','L-PC'],axis=1)
    return df2['ATR']

def renko_DF(DF):
    "function to convert ohlc data into renko bricks"
    df = DF.copy()
    df.reset_index(inplace=True)
    df = df.iloc[:,[0,1,2,3,4,5]]
    df.columns = ["date","open","high","low","close","volume"]
    df2 = Renko(df)
    df2.brick_size = max(0.5,round(ATR(DF,120)["ATR"][-1],0))
    renko_df = df2.get_bricks()
    renko_df["bar_num"] = np.where(renko_df["uptrend"]==True,1,np.where(renko_df["uptrend"]==False,-1,0))
    for i in range(1,len(renko_df["bar_num"])):
        if renko_df["bar_num"][i]>0 and renko_df["bar_num"][i-1]>0:
            renko_df["bar_num"][i]+=renko_df["bar_num"][i-1]
        elif renko_df["bar_num"][i]<0 and renko_df["bar_num"][i-1]<0:
            renko_df["bar_num"][i]+=renko_df["bar_num"][i-1]
    renko_df.drop_duplicates(subset="date",keep="last",inplace=True)
    return renko_df

def OBV(DF):
    """function to calculate On Balance Volume"""
    df = DF.copy()
    df['daily_ret'] = df['Adj Close'].pct_change()
    df['direction'] = np.where(df['daily_ret']>=0,1,-1)
    df['direction'][0] = 0
    df['vol_adj'] = df['Volume'] * df['direction']
    df['obv'] = df['vol_adj'].cumsum()
    return df['obv']

def xirr(transactions):
    years = [(ta[0] - transactions[0][0]).days / 365.0 for ta in transactions]
    residual = 1
    step = 0.05
    guess = 0.05
    epsilon = 0.0001
    limit = 10000
    while abs(residual) > epsilon and limit > 0:
        limit -= 1
        residual = 0.0
        for i, ta in enumerate(transactions):
            residual += ta[1] / pow(guess, years[i])
        if abs(residual) > epsilon:
            if residual > 0:
                guess += step
            else:
                guess -= step
                step /= 2.0
    return guess-1


def exposure_time(DF):
    #function to calculate exposure time
    df = DF.copy()
    sr = np.count_nonzero(df["mon_ret"])/len(df["mon_ret"])
    return sr

def Equity_Peak(DF):
    #function to calculate peak equity
    df = DF.copy()
    df["cum_return"] = (1 + df["mon_ret"]).cumprod()
    df["cum_roll_max"] = df["cum_return"].cummax()
    peak_equity = df["cum_roll_max"].max()
    return peak_equity

def Equity_Final(DF):
    #function to calculate peak equity
    df = DF.copy()
    df["cum_return"] = (1 + df["mon_ret"]).cumprod()
    final_equity = df["cum_return"][-1]
    return final_equity

def period_maxdrawdown(DF):

  df=DF
  df["cum_return"] = (1 + df["mon_ret"]).cumprod()
  df["cum_roll_max"] = df["cum_return"].cummax()
  df["drawdown"] = df["cum_roll_max"] - df["cum_return"]
  df["drawdown_pct"] = df["drawdown"]/df["cum_roll_max"]
  res = np.where(df["drawdown_pct"] == 0)[0]
  temp=pd.DataFrame(res)
  temp2=temp.shift(-1)-temp-1
  max_dd_period=temp2.max()
  return max_dd_period

def period_average_drawdown(DF):

  df=DF
  df["cum_return"] = (1 + df["mon_ret"]).cumprod()
  df["cum_roll_max"] = df["cum_return"].cummax()
  df["drawdown"] = df["cum_roll_max"] - df["cum_return"]
  df["drawdown_pct"] = df["drawdown"]/df["cum_roll_max"]
  res = np.where(df["drawdown_pct"] == 0)[0]
  temp=pd.DataFrame(res)
  temp2=temp.shift(-1)-temp-1
  temp2 = temp2.replace(0, np.NaN)
  average_drawdown_period=temp2.mean()
  return average_drawdown_period



def sortino(DF,rf):
    "function to calculate sortino ratio ; rf is the risk free rate"
    df = DF.copy()
    df["neg_ret"] = np.where(df["mon_ret"]<0,df["mon_ret"],0)
    neg_vol = df["neg_ret"].std() * np.sqrt(252)
    sr = (CAGR(df) - rf)/neg_vol
    return sr

def calmar(DF):
    "function to calculate calmar ratio"
    df = DF.copy()
    clmr = CAGR(df)/max_dd(df)
    return clmr

start = dt.datetime.today()-dt.timedelta(1000)
end = dt.datetime.today()
#tickers = ["^VIX","^GSPC" ]
#tickers = ["^EVZ"]

#GET PMI DATA

quandl.ApiConfig.api_key = "rs_LHnBv3FA3X8h8DnF6"
mydata = quandl.get("ISM/MAN_PMI", authtoken="rs_LHnBv3FA3X8h8DnF6",start_date=start,enddate=end)
mydata['shifted_date'] = mydata.index - pd.Timedelta(days=1)
mydata.index=mydata['shifted_date']
### PMI Data got


Daily_VIX=web.DataReader('^VIX', 'yahoo', start, end)
df1_IV = smooth_data(Daily_VIX)

Daily_SP500=web.DataReader('EURUSD=X', 'yahoo', start, end)

#Daily_SP500=Daily_SP500.resample('M').agg({'Open': 'first', 'High': np.max, 'Low':np.min,'Close': 'last','Adj Close': 'last' })
#Daily_SP500=Daily_SP500.resample('M').last()
Daily_SP500["ATR"] = ATR(Daily_SP500,14)
Daily_SP500["roll_max_cp"] = Daily_SP500['High'].rolling(20).max()
Daily_SP500["roll_min_cp"] = Daily_SP500['Low'].rolling(20).min()
Daily_SP500['PMI']=mydata['PMI']

tickers_signal = ""
tickers_ret = [0]
signal = [0]
Buy_signal=[]
Sell_signal=[]
Close_signal=[]
#Initializing Signals
Buy_signal.append(np.NaN)
Sell_signal.append(np.NaN)
Close_signal.append(np.NaN)

#For trade-wise data
column_names = ['Entry_Date', 'Buy_or_Sell', 'Entry_Price','Exit_Price', 'Exit_Date']
Trade_data = pd.DataFrame(columns = column_names)
flag=0


EntryDate=[]
BuySell=[]
EntryPrice=[]
ExitPrice=[]
ExitDate=[]

for i in range(1,len(Daily_SP500)):
  temp=str(Daily_SP500['Adj Close'][i])
  if tickers_signal == "":
    tickers_ret.append(0)
    if Daily_SP500["High"][i]>=Daily_SP500["roll_max_cp"][i]:
      tickers_signal = "Buy"
      Buy_signal.append(Daily_SP500['Adj Close'][i])
      Sell_signal.append(np.NaN)
      Close_signal.append(np.NaN)
      EntryDate.append(Daily_SP500.index.values[i])
      BuySell.append('Buy')
      EntryPrice.append(Daily_SP500['Adj Close'][i])

    elif Daily_SP500["Low"][i]<=Daily_SP500["roll_min_cp"][i]:
      tickers_signal = "Sell"
      Buy_signal.append(np.NaN)
      Sell_signal.append(Daily_SP500['Adj Close'][i])
      Close_signal.append(np.NaN)
      EntryDate.append(Daily_SP500.index.values[i])
      BuySell.append('Sell')
      EntryPrice.append(Daily_SP500['Adj Close'][i])
    else:
      Buy_signal.append(np.NaN)
      Sell_signal.append(np.NaN)
      Close_signal.append(np.NaN)
  elif tickers_signal == "Buy":
    if Daily_SP500["Low"][i]<Daily_SP500["Adj Close"][i-1] - Daily_SP500["ATR"][i-1]:
      tickers_signal = ""
      tickers_ret.append(((Daily_SP500["Adj Close"][i-1] - Daily_SP500["ATR"][i-1])/Daily_SP500["Adj Close"][i-1])-1)
      Buy_signal.append(np.NaN)
      Sell_signal.append(np.NaN)
      Close_signal.append(Daily_SP500["Adj Close"][i-1] - Daily_SP500["ATR"][i-1])
      ExitPrice.append(Daily_SP500["Adj Close"][i-1] - Daily_SP500["ATR"][i-1])
      ExitDate.append(Daily_SP500.index.values[i])
    elif Daily_SP500["Low"][i]<=Daily_SP500["roll_min_cp"][i] :
      tickers_signal = "Sell"
      tickers_ret.append((Daily_SP500["Adj Close"][i]/Daily_SP500["Adj Close"][i-1])-1)
      Buy_signal.append(np.NaN)
      Sell_signal.append(Daily_SP500['Adj Close'][i])
      Close_signal.append(Daily_SP500['Adj Close'][i])
      ExitPrice.append(Daily_SP500["Adj Close"][i])
      ExitDate.append(Daily_SP500.index.values[i])
      EntryDate.append(Daily_SP500.index.values[i])
      BuySell.append('Sell')
      EntryPrice.append(Daily_SP500['Adj Close'][i])
    else:
      tickers_ret.append((Daily_SP500["Adj Close"][i]/Daily_SP500["Adj Close"][i-1])-1)
      Buy_signal.append(np.NaN)
      Sell_signal.append(np.NaN)
      Close_signal.append(np.NaN)
  elif tickers_signal == "Sell":
    if Daily_SP500["High"][i]>Daily_SP500["Adj Close"][i-1] + Daily_SP500["ATR"][i-1]:
      tickers_signal = ""
      tickers_ret.append((Daily_SP500["Adj Close"][i-1]/(Daily_SP500["Adj Close"][i-1] + Daily_SP500["ATR"][i-1]))-1)
      Buy_signal.append(np.NaN)
      Sell_signal.append(np.NaN)
      Close_signal.append(Daily_SP500["Adj Close"][i-1] + Daily_SP500["ATR"][i-1])
      ExitPrice.append(Daily_SP500["Adj Close"][i-1] + Daily_SP500["ATR"][i-1])
      ExitDate.append(Daily_SP500.index.values[i])
    elif Daily_SP500["High"][i]>=Daily_SP500["roll_max_cp"][i] :
      tickers_signal = "Buy"
      tickers_ret.append((Daily_SP500["Adj Close"][i-1]/Daily_SP500["Adj Close"][i])-1)
      Buy_signal.append(Daily_SP500['Adj Close'][i])
      Sell_signal.append(np.NaN)
      Close_signal.append(Daily_SP500['Adj Close'][i])
      ExitPrice.append(Daily_SP500["Adj Close"][i])
      ExitDate.append(Daily_SP500.index.values[i])
      EntryDate.append(Daily_SP500.index.values[i])
      BuySell.append('Buy')
      EntryPrice.append(Daily_SP500['Adj Close'][i])
    else:
      tickers_ret.append((Daily_SP500["Adj Close"][i-1]/Daily_SP500["Adj Close"][i])-1)
      Buy_signal.append(np.NaN)
      Sell_signal.append(np.NaN)
      Close_signal.append(np.NaN)

#collate all trade data in one place
Trade_data['Entry_Date']=np.array(EntryDate)
Trade_data['Buy_or_Sell']=np.array(BuySell)
Trade_data['Entry_Price']=np.array(EntryPrice)
Trade_data['Exit_Date']=np.array(ExitDate)
Trade_data['Exit_Price']=np.array(ExitPrice)
Trade_data['temp'] = Trade_data.Buy_or_Sell.apply(
               lambda x: (1 if x == 'Buy' else -1))
Trade_data['PnL'] = (Trade_data.Exit_Price- Trade_data.Entry_Price)/Trade_data.Entry_Price
Trade_data['Trade_Duration'] = (Trade_data.Exit_Date- Trade_data.Entry_Date)


#collate other data in Daily_SP500
Daily_SP500["mon_ret"] = np.array(tickers_ret)
#Daily_SP500["ret"] = Daily_SP500["Adj Close"].pct_change()
Daily_SP500["close_slope"] = slope(Daily_SP500["Adj Close"],5)
Daily_SP500["PMI_slope"] = slope(Daily_SP500["PMI"],5)
Daily_SP500["PMI_a"] = slope(Daily_SP500["PMI_slope"],5)
Daily_SP500['buy_data']=np.array(Buy_signal)
Daily_SP500['sell_data']=np.array(Sell_signal)
Daily_SP500['trade_close_data']=np.array(Close_signal)
# calculating overall strategy's KPIs

print("CAGR="+ str(100*CAGR(Daily_SP500))+"%")
print("Sharpe="+ str(sharpe(Daily_SP500,0.025)))
print("Max Drawdown="+ str(100*max_dd(Daily_SP500)  )+"%")
print("Exposure time ="+ str(100*exposure_time(Daily_SP500)  )+"%")
print("Peak Equity ="+ str(100*Equity_Peak(Daily_SP500)  )+"%")
print("Average Drawdown Period ="+ str(period_average_drawdown(Daily_SP500)  ))
print("Max Drawdown Period ="+ str(period_maxdrawdown(Daily_SP500)  ))



print("#Trades="+ str(len(Trade_data)))
print("Winrate%="+ str(100*len(Trade_data.loc[Trade_data.PnL > 0])/len(Trade_data))+"%")
print("Best Trade%="+ str(100*Trade_data['PnL'].max())+"%")
print("Worst Trade%="+ str(100*Trade_data['PnL'].min())+"%")
print("Max Trade Duration="+ str(Trade_data['Trade_Duration'].max()))
print("Avg Trade Duration="+ str(Trade_data['Trade_Duration'].mean()))
print('Profit Factor='+str(-sum(Trade_data['PnL'].to_numpy().clip(min=0))/sum(Trade_data['PnL'].to_numpy().clip(max=0))))

# create figure and axis objects with subplots()
fig,ax = plt.subplots()

plt.figure(figsize=(15,5))
ax.plot(Daily_SP500.index, Daily_SP500["Adj Close"], color="blue",label='S&P500',alpha=0.3)
#plt.plot(Daily_SP500["Adj Close"],label='S&P500',alpha=0.35)
ax.scatter(Daily_SP500.index,Daily_SP500['buy_data'], label="BUY", marker = '^',color='Green')
ax.scatter(Daily_SP500.index,Daily_SP500['sell_data'], label="Sell", marker = 'v',color='Red')
ax.scatter(Daily_SP500.index,Daily_SP500['trade_close_data'], label="Trade_close", marker = 'o',color='black',alpha=0.15)
ax2=ax.twinx()
# make a plot with different y-axis using second axis object
ax2.plot(Daily_SP500.index, (1+Daily_SP500["mon_ret"]).cumprod(), color="brown")

plt.show()


# vizualization of strategy return
#Daily_SP500.to_csv(r'\\Downloads\PMI.csv', index=True)
#files.download(r'\\Downloads\PMI.csv')